package nodebox.node;import com.google.common.base.Charsets;import com.google.common.io.Files;import nodebox.graphics.Point;import nodebox.util.LoadException;import nu.xom.*;import java.io.File;import java.io.IOException;import java.lang.reflect.Method;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;import static com.google.common.base.Preconditions.checkArgument;/** * Helper class that contains all NodeLibrary upgrade migrations. */public class NodeLibraryUpgrades {    private static Map<String, Method> upgradeMap = new HashMap<String, Method>();    /**     * Lookup an upgrade method by name.     * <p/>     * This method is not compatible     *     * @param methodName The upgrade method name.     * @return The Method object, to be invoked.     */    private static Method upgradeMethod(String methodName) {        try {            return NodeLibraryUpgrades.class.getMethod(methodName, String.class);        } catch (NoSuchMethodException e) {            throw new RuntimeException(e);        }    }    static {        upgradeMap.put("1.0", upgradeMethod("upgrade1to2"));        upgradeMap.put("2", upgradeMethod("upgrade2to3"));    }    private static final Pattern formatVersionPattern = Pattern.compile("formatVersion=['\"]([\\d\\.]+)['\"]");    public static String parseFormatVersion(String xml) {        Matcher m = formatVersionPattern.matcher(xml);        if (!m.find()) throw new RuntimeException("Invalid NodeBox file: " + xml);        return m.group(1);    }    private static String readFile(File file) {        try {            return Files.toString(file, Charsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    /**     * Upgrade the given file to the latest library version. The file is supposed to be a NDBX file.     * <p/>     * It is harmless to pass in current version NDBX files.     *     * @param file The .ndbx file to upgrade.     * @return An upgrade result, containing warnings, correct XML code and a NodeLibrary object.     * @throws nodebox.util.LoadException If the upgrade fails for some reason.     */    public static UpgradeResult upgrade(File file) throws LoadException {        return upgradeTo(file, NodeLibrary.CURRENT_FORMAT_VERSION);    }    /**     * Upgrade the given file to the target version. The file is supposed to be a NDBX file.     * <p/>     * It is harmless to pass in current version NDBX files.     *     * @param file The .ndbx file to upgrade.     * @return An upgrade result, containing warnings, correct XML code and a NodeLibrary object.     * @throws LoadException If the upgrade fails for some reason.     */    public static UpgradeResult upgradeTo(File file, String targetVersion) throws LoadException {        String currentXml = readFile(file);        String currentVersion = parseFormatVersion(currentXml);        ArrayList<String> warnings = new ArrayList<String>();        // Avoid upgrades getting stuck in an infinite loop.        int tries = 0;        while (!currentVersion.equals(targetVersion) && tries < 100) {            Method upgradeMethod = upgradeMap.get(currentVersion);            if (upgradeMethod == null) {                throw new LoadException(file, "Unsupported version " + currentVersion + ": this file is too old or too new.");            }            try {                UpgradeStringResult result = (UpgradeStringResult) upgradeMethod.invoke(null, currentXml);                warnings.addAll(result.warnings);                currentXml = result.xml;            } catch (Exception e) {                throw new LoadException(file, "Upgrading to " + currentVersion + " failed.", e);            }            currentVersion = parseFormatVersion(currentXml);            tries++;        }        if (tries >= 100) {            throw new LoadException(file, "Got stuck in an infinite loop when trying to upgrade from " + currentVersion);        }        return new UpgradeResult(file, currentXml, warnings);    }    public static UpgradeStringResult upgrade1to2(String inputXml) throws LoadException {        // Version 2: Vertical node networks        // 1. Rotate all nodes 90 degrees by reversing X and Y positions.        // 2. Convert from pixel units to grid units by dividing by GRID_CELL_SIZE.        final int GRID_CELL_SIZE = 48;        UpgradeOp verticalNodesOp = new UpgradeOp() {            @Override            public void apply(Element e) {                if (!e.getLocalName().equals("node")) return;                Attribute position = e.getAttribute("position");                if (position == null) return;                Point pt = Point.valueOf(position.getValue());                Point reversedPoint = new Point(pt.y, pt.x);                Point gridPoint = new Point(Math.round(reversedPoint.x / GRID_CELL_SIZE) * 3, Math.round(reversedPoint.y / GRID_CELL_SIZE));                position.setValue(String.valueOf(gridPoint));            }            @Override            public void end(Element root) {                addWarning("Nodes have been rotated. Your network will look different.");            }        };        return transformXml(inputXml, "2", verticalNodesOp);    }    public static UpgradeStringResult upgrade2to3(String inputXml) throws LoadException {        // Version 3: Rename math.to_integer to math.round.        UpgradeOp changePrototypeOp = new ChangePrototypeOp("math.to_integer", "math.round");        UpgradeOp renameOp = new RenameNodeOp("to_integer", "round");        return transformXml(inputXml, "3", changePrototypeOp, renameOp);    }    private static Set<String> getChildNodeNames(ParentNode parent) {        HashSet<String> names = new HashSet<String>();        Nodes children = parent.query("node");        for (int i = 0; i < children.size(); i++) {            nu.xom.Node childNode = children.get(i);            if (childNode instanceof Element) {                Element e = (Element) children.get(i);                names.add(e.getAttribute("name").getValue());            }        }        return names;    }    private static String uniqueName(String prefix, Set<String> existingNames) {        int counter = 1;        while (true) {            String suggestedName = prefix + counter;            if (!existingNames.contains(suggestedName)) {                return suggestedName;            }            counter++;        }    }    private static void renameRenderedChildReference(Element element, String oldNodeName, String newNodeName) {        Attribute renderedChildReference = element.getAttribute("renderedChild");        if (renderedChildReference == null) return;        String oldRenderedChild = renderedChildReference.getValue();        if (oldRenderedChild.equals(oldNodeName))            renderedChildReference.setValue(newNodeName);    }    private static void renamePortReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {        for (int i = 0; i < elements.size(); i++) {            Element c = elements.get(i);            Attribute portReference = c.getAttribute(attributeName);            if (portReference == null) continue;            Iterator<String> portRefIterator = NodeLibrary.PORT_NAME_SPLITTER.split(portReference.getValue()).iterator();            String nodeName = portRefIterator.next();            String portName = portRefIterator.next();            if (oldNodeName.equals(nodeName)) {                portReference.setValue(String.format("%s.%s", newNodeName, portName));            }        }    }    private static void renameNodeReference(Elements elements, String attributeName, String oldNodeName, String newNodeName) {        for (int i = 0; i < elements.size(); i++) {            Element c = elements.get(i);            Attribute nodeRef = c.getAttribute(attributeName);            String nodeName = nodeRef.getValue();            if (oldNodeName.equals(nodeName)) {                nodeRef.setValue(newNodeName);            }        }    }    private static abstract class UpgradeOp {        private List<String> warnings = new ArrayList<String>();        public void start(Element root) {        }        public void end(Element root) {        }        public abstract void apply(Element e);        public void addWarning(String warning) {            warnings.add(warning);        }        public List<String> getWarnings() {            return warnings;        }    }    private static class ChangePrototypeOp extends UpgradeOp {        private String oldPrototype;        private String newPrototype;        private ChangePrototypeOp(String oldPrototype, String newPrototype) {            this.oldPrototype = oldPrototype;            this.newPrototype = newPrototype;        }        public void apply(Element e) {            if (e.getLocalName().equals("node")) {                Attribute prototype = e.getAttribute("prototype");                if (prototype != null && prototype.getValue().equals(oldPrototype)) {                    prototype.setValue(newPrototype);                }            }        }    }    private static class RenameNodeOp extends UpgradeOp {        private String oldPrefix;        private String newPrefix;        private RenameNodeOp(String oldPrefix, String newPrefix) {            this.oldPrefix = oldPrefix;            this.newPrefix = newPrefix;        }        @Override        public void apply(Element e) {            if (e.getLocalName().equals("node")) {                Attribute name = e.getAttribute("name");                if (name != null && name.getValue().startsWith(oldPrefix)) {                    String oldNodeName = name.getValue();                    Set<String> childNames = getChildNodeNames(e.getParent());                    String newNodeName = uniqueName(newPrefix, childNames);                    name.setValue(newNodeName);                    Element parent = (Element) e.getParent();                    renameRenderedChildReference(parent, oldNodeName, newNodeName);                    Elements connections = parent.getChildElements("conn");                    renamePortReference(connections, "input", oldNodeName, newNodeName);                    renameNodeReference(connections, "output", oldNodeName, newNodeName);                    Elements ports = parent.getChildElements("port");                    renamePortReference(ports, "childReference", oldNodeName, newNodeName);                }            }        }    }    private static UpgradeStringResult transformXml(String xml, String newFormatVersion, UpgradeOp... ops) {        try {            Document document = new Builder().build(xml, null);            // Check that this is a NodeBox document and set the new formatVersion.            Element root = document.getRootElement();            checkArgument(root.getLocalName().equals("ndbx"), "This is not a valid NodeBox document.");            root.addAttribute(new Attribute("formatVersion", newFormatVersion));            // Loop through all upgrade operations.            ArrayList<String> warnings = new ArrayList<String>();            for (UpgradeOp op : ops) {                op.start(root);                transformXmlRecursive(document.getRootElement(), op);                op.end(root);                warnings.addAll(op.getWarnings());            }            return new UpgradeStringResult(document.toXML(), warnings);        } catch (Exception e) {            throw new RuntimeException("Error while upgrading to " + newFormatVersion + ".", e);        }    }    private static void transformXmlRecursive(Element e, UpgradeOp op) {        op.apply(e);        Elements children = e.getChildElements();        for (int i = 0; i < children.size(); i++) {            Element child = children.get(i);            transformXmlRecursive(child, op);        }    }    private static class UpgradeStringResult {        private final String xml;        private final List<String> warnings;        private UpgradeStringResult(String xml, List<String> warnings) {            this.xml = xml;            this.warnings = warnings;        }    }}