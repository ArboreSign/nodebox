<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<ndbx formatVersion="0.9" type="file">
  <node name="generator" prototype="builtins.root" type="nodebox.graphics.Geometry" x="10" y="90">
    <description>Template for creating nodes that generator vector data.</description>
    <param name="_code">
      <value type="python"><![CDATA[# This node serves as a template for writing your own vector generators.
# Read the code in cook and replace it with your own.
from nodebox.graphics import Path

def cook(self):
    # Replace the code below.
    # Create a new path object.
    p = Path()
    # Call the rect method to draw something within the path.
    p.rect(0, 0, 100, 100)
    # Return the path object.
    return p.asGeometry()]]></value>
    </param>
    <param name="_image">
      <value>generator.png</value>
    </param>
  </node>
  <node name="filter" prototype="generator" x="10" y="250">
    <description>Template for creating nodes that manipulate vector data.</description>
    <port name="shape"/>
    <param name="_code">
      <value type="python"><![CDATA[# This node serves as a template for writing your own vector filters.
# Read the code in cook() and replace it with your own.

def cook(self):
    # Replace the code below
    # Check if a shape is connected.
    if self.shape is None: return None
    # If you're changing the shape, make sure to clone it.
    new_shape = self.shape.clone()
    # Do something with the cloned copy.
    new_shape.rotate(45)
    # Return the transformed shape.
    return new_shape]]></value>
    </param>
    <param name="_image">
      <value>filter.png</value>
    </param>
  </node>
  <node name="color" prototype="filter" x="250" y="250">
    <description>Change the color of a shape.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    if self.shape is None: return None
    new_shape = self.shape.clone()
    for path in new_shape.paths:
        path.fillColor = self.fill
        if self.strokeWidth > 0:
            path.strokeColor = self.stroke
            path.strokeWidth = self.strokeWidth
        else:
            path.strokeColor = None
    return new_shape]]></value>
    </param>
    <param name="_image">
      <value>color.png</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="compound" prototype="filter" x="90" y="250">
    <description>Add, subtract or intersect geometry.</description>
    <port name="shapeB"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Geometry, Color

def cook(self):
     if self.shape is None: return None
     if self.shapeB is None: return self.shape.clone()
     # The invert turns the operation around.
     if self.invert_difference:
         shape_a, shape_b = self.shapeB, self.shape
     else:
         shape_a, shape_b = self.shape, self.shapeB
     # We're not changing the original geometry so there is no need to clone.
     # Unite all the paths from geometry A.
     compound_a = None
     for path_a in shape_a.paths:
         if compound_a is None:
             compound_a = path_a
         else:
             compound_a = compound_a.united(path_a)
     # Unite all the paths from geometry B.
     compound_b = None
     for path_b in shape_b.paths:
         if compound_b is None:
             compound_b = path_b
         else:
             compound_b = compound_b.united(path_b)
     # Final check to see if the two compound paths contain data.
     if compound_a is None or compound_b is None: return None
     # Combine the two compound paths using the given function.
     f = self.function
     if f == "united":
         compound = compound_a.united(compound_b)
     elif f == "subtracted":
         compound = compound_a.subtracted(compound_b)
     elif f == "intersected":
         compound = compound_a.intersected(compound_b)
     else:
         return None
     # Set the color of the path.
     compound.fillColor = self.fill
     if self.strokeWidth > 0:
         compound.strokeColor = self.stroke
         compound.strokeWidth = self.strokeWidth
     return compound.asGeometry()]]></value>
    </param>
    <param name="_image">
      <value>compound.png</value>
    </param>
    <param name="function" type="string" widget="menu">
      <value>united</value>
      <menu key="united">union</menu>
      <menu key="subtracted">difference</menu>
      <menu key="intersected">intersect</menu>
    </param>
    <param name="invert_difference" type="int" widget="toggle">
      <value>0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="copy" prototype="filter" x="170" y="250">
    <description>Create multiple copies of a shape.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.node import StampExpression
from nodebox.graphics import Geometry, Transform

def cook(self):
    if self.shape is None:
        return None
    g = Geometry()
    tx = ty = r = 0.0
    sx = sy = 1.0
    if self.stamp:
        stamp = StampExpression(self.node, "expr")
    for i in xrange(self.copies):
        if self.stamp:
            context.put('CNUM', i)
            stamp.evaluate(context)
            self.node.stampExpressions(context)
        t = Transform()
        # Each letter of the order describes an operation.
        for op in self.order:
            if op == 't':
                t.translate(tx, ty)
            elif op == 'r':
                t.rotate(r)
            elif op == 's':
                t.scale(sx, sy)
        new_shape = t.map(self.shape)
        g.extend(new_shape)
        tx += self.tx
        ty += self.ty
        r += self.r
        sx += self.sx / 100.0
        sy += self.sy / 100.0
    return g]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import PointHandle

def cook(self):
    return PointHandle(self.node, "tx", "ty")]]></value>
    </param>
    <param name="_image">
      <value>copy.png</value>
    </param>
    <param bounding="hard" min="1.0" name="copies" type="int">
      <value>1</value>
    </param>
    <param name="order" type="string" widget="menu">
      <value>tsr</value>
      <menu key="srt">Scale Rot Trans</menu>
      <menu key="str">Scale Trans Rot</menu>
      <menu key="rst">Rot Scale Trans</menu>
      <menu key="rts">Rot Trans Scale</menu>
      <menu key="tsr">Trans Scale Rot</menu>
      <menu key="trs">Trans Rot Scale</menu>
    </param>
    <param label="Translate X" name="tx" type="float">
      <value>0.0</value>
    </param>
    <param label="Translate Y" name="ty" type="float">
      <value>0.0</value>
    </param>
    <param label="Rotate" name="r" type="float">
      <value>0.0</value>
    </param>
    <param label="Scale X" name="sx" type="float">
      <value>0.0</value>
    </param>
    <param label="Scale Y" name="sy" type="float">
      <value>0.0</value>
    </param>
    <param label="Copy Stamping" name="stamp" type="int" widget="toggle">
      <value>0</value>
    </param>
    <param help="" label="Expression" name="expr" type="string" widget="stamp_expression">
      <value/>
    </param>
  </node>
  <node name="curve" prototype="generator" x="330" y="170">
    <description>Create an arbitrary curve or path</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path
import svg

template_svg = """<?xml version="1.0"?>
<svg>'
<g>
<path d="%s" />
</g>
</svg>"""

def cook(self):
    s = template_svg % self.path
    p = svg.parse(s)[0]
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.asGeometry()
]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Color
from nodebox.handle import AbstractHandle

from math import sin, cos, atan, pi, degrees, radians, sqrt, pow

import svg

template_svg = """<?xml version="1.0"?>
<svg>'
<g>
<path d="%s" />
</g>
</svg>"""

MOVETO, LINETO, CURVETO, CLOSE = range(4)

class Point(object):
    def __init__(self, *args):
        if len(args) == 2:
            self.x, self.y = args
        elif len(args) == 1:
            self.x, self.y = args[0]
        elif len(args) == 0:
            self.x = self.y = 0.0

    def __repr__(self):
        return "Point(x=%.3f, y=%.3f)" % (self.x, self.y)
       
    def __eq__(self, other):
        if other is None: return False
        return self.x == other.x and self.y == other.y
       
    def __ne__(self, other):
        return not self.__eq__(other)

              
class PathElement(object):
    def __init__(self, cmd=None, pts=None):
        self.cmd = cmd
        if cmd == MOVETO:
            assert len(pts) == 1
            self.x, self.y = pts[0]
            self.ctrl1 = Point(pts[0])
            self.ctrl2 = Point(pts[0])
        elif cmd == LINETO:
            assert len(pts) == 1
            self.x, self.y = pts[0]
            self.ctrl1 = Point(pts[0])
            self.ctrl2 = Point(pts[0])
        elif cmd == CURVETO:
            assert len(pts) == 3
            self.ctrl1 = Point(pts[0])
            self.ctrl2 = Point(pts[1])
            self.x, self.y = pts[2]
        elif cmd == CLOSE:
            assert pts is None or len(pts) == 0
            self.x = self.y = 0.0
            self.ctrl1 = Point(0.0, 0.0)
            self.ctrl2 = Point(0.0, 0.0)
        else:
            self.x = self.y = 0.0
            self.ctrl1 = Point()
            self.ctrl2 = Point()

    def __repr__(self):
        if self.cmd == MOVETO:
            return "PathElement(MOVETO, ((%.3f, %.3f),))" % (self.x, self.y)
        elif self.cmd == LINETO:
            return "PathElement(LINETO, ((%.3f, %.3f),))" % (self.x, self.y)
        elif self.cmd == CURVETO:
            return "PathElement(CURVETO, ((%.3f, %.3f), (%.3f, %s), (%.3f, %.3f))" % \
                (self.ctrl1.x, self.ctrl1.y, self.ctrl2.x, self.ctrl2.y, self.x, self.y)
        elif self.cmd == CLOSE:
            return "PathElement(CLOSE)"
           
    def __eq__(self, other):
        if other is None: return False
        if self.cmd != other.cmd: return False
        return self.x == other.x and self.y == other.y \
            and self.ctrl1 == other.ctrl1 and self.ctrl2 == other.ctrl2
       
    def __ne__(self, other):
        return not self.__eq__(other)

                                
class BezierPathEditor(AbstractHandle):
    def __init__(self, node):
        AbstractHandle.__init__(self, node)
        self.path = None
        self.path_string = ""
        self._points = []
        if self.node.asString("path"):
            self.import_svg()
        self.reset()

    def reset(self):
        # These variables discern between different
        # modes of interaction.
        # In add-mode, new contains the last point added.
        # In edit-mode, edit contains the index of the point
        # in the path being edited.

        self.new = None
        self.edit = None
        self.editing = False
        self.insert = False
        self.inserting = False
        
        self.drag_point = False
        self.drag_handle1 = False
        self.drag_handle2 = False
        
        # Colors used to draw interface elements.
        
        self.strokewidth = 0.75
        self.path_color = Color(0.2, 0.2, 0.2)
        self.path_fill = Color(0, 0, 0, 0)
        self.handle_color = Color(0.6, 0.6, 0.6)
        self.new_color = Color(0.8, 0.8, 0.8)

        # Different states for button actions.
        # When delete contains a number,
        # delete that index from the path.
        # When moveto contains True,
        # do a MOVETO before adding the next new point.

        self.delete = None
        self.moveto = None
        self.last_moveto = None
        self.btn_r = 5
        self.btn_x = -5-1
        self.btn_y = -5*2

        # Keyboard keys pressed.
        
        self.keydown = False
        self._keycode = None
        self.last_key = None
        self.last_keycode = None
                
        self._mouseXY = None
        self.mousedown = False
        
    def overlap(self, x1, y1, x2, y2, r=5):
        
        """ Returns True when point 1 and point 2 overlap.
        
        There is an r treshold in which point 1 and point 2
        are considered to overlap.
        
        """
        
        if abs(x2-x1) < r and abs(y2-y1) < r:
            return True
        else:
            return False
    
    def reflect(self, x0, y0, x, y):
        
        """ Reflects the point x, y through origin x0, y0.
        """
                
        rx = x0 - (x-x0)
        ry = y0 - (y-y0)
        return rx, ry

    def angle(self, x0, y0, x1, y1):
        
        """ Calculates the angle between two points.
        """
    
        a = degrees( atan((y1-y0) / (x1-x0+0.00001)) ) + 360
        if x1-x0 < 0: a += 180
        return a

    def distance(self, x0, y0, x1, y1):
    
        """ Calculates the distance between two points.
        """
    
        return sqrt(pow(x1-x0, 2) + pow(y1-y0, 2))
        
    def coordinates(self, x0, y0, distance, angle):
        
        """ Calculates the coordinates of a point from the origin.
        """
        
        x = x0 + cos(radians(angle)) * distance
        y = y0 + sin(radians(angle)) * distance
        return Point(x, y)

    def contains_point(self, x, y, d=2):
        
        """ Returns true when x, y is on the path stroke outline.
        """
        if self.path != None and len(self._points) > 1 \
        and self.path.contains(x, y):
            # If all points around the mouse are also part of the path,
            # this means we are somewhere INSIDE the path.
            # Only points near the edge (i.e. on the outline stroke)
            # should propagate.
            if not self.path.contains(x+d, y) \
            or not self.path.contains(x, y+d) \
            or not self.path.contains(x-d, y) \
            or not self.path.contains(x, y-d) \
            or not self.path.contains(x+d, y+d) \
            or not self.path.contains(x-d, y-d) \
            or not self.path.contains(x+d, y-d) \
            or not self.path.contains(x-d, y+d):
                return True

        return False

    def insert_point(self, x, y):
        pass
    
    def update(self):
        
        """ Update runs each frame to check for mouse interaction.
        
        Alters the path by allowing the user to add new points,
        drag point handles and move their location.
        Updates are automatically stored as SVG
        in the given filename.
        
        """
        if self.node.asString("path") != self.path_string:
            self.import_svg()
            self.reset()
        
        x, y = self.mouse()
        
        if self.mousedown:
            # Handle buttons first.
            # When pressing down on a button, all other action halts.
            # Buttons appear near a point being edited.
            # Once clicked, actions are resolved.
            if self.edit != None \
            and not self.drag_point \
            and not self.drag_handle1 \
            and not self.drag_handle2:
                pt = self._points[self.edit]
                dx = pt.x+self.btn_x
                dy = pt.y+self.btn_y
                # The delete button
                if self.overlap(dx, dy, x, y, r=self.btn_r):
                    self.delete = self.edit
                    return
                # The moveto button,
                # active on the last point in the path.
                dx += self.btn_r*2 + 2
                if self.edit == len(self._points) -1 and \
                   self.overlap(dx, dy, x, y, r=self.btn_r):
                    self.moveto = self.edit
                    return
                    
            if self.insert:
                self.inserting = True
                return
            
            # When not dragging a point or the handle of a point,
            # i.e. the mousebutton was released and then pressed again,
            # check to see if a point on the path is pressed.
            # When this point is not the last new point,
            # enter edit mode.
            if not self.drag_point and \
               not self.drag_handle1 and \
               not self.drag_handle2:
                self.editing = False
                indices = range(len(self._points))
                indices.reverse()
                for i in indices:
                    pt = self._points[i]
                    if pt != self.new \
                    and self.overlap(x, y, pt.x, pt.y) \
                    and self.new == None:
                        # Don't select a point if in fact
                        # it is at the same location of the first handle 
                        # of the point we are currently editing.
                        if self.edit == i+1 \
                        and self.overlap(self._points[i+1].ctrl1.x,
                                         self._points[i+1].ctrl1.y, x, y):
                            continue
                        else:
                            self.edit = i
                            self.editing = True
                            break
            
            # When the mouse button is down,
            # edit mode continues as long as
            # a point or handle is dragged.
            # Else, stop editing and switch to add-mode
            # (the user is clicking somewhere on the canvas).
            if not self.editing:
                if self.edit != None:
                    pt = self._points[self.edit]
                    if self.overlap(pt.ctrl1.x, pt.ctrl1.y, x, y) or \
                       self.overlap(pt.ctrl2.x, pt.ctrl2.y, x, y):
                        self.editing = True
                    else:
                        self.edit = None
                    
            # When not in edit mode, there are two options.
            # Either no new point is defined and the user is
            # clicking somewhere on the canvas (add a new point)
            # or the user is dragging the handle of the new point.
            # Adding a new point is a fluid click-to-locate and
            # drag-to-curve action.
            if self.edit == None:
                if self.new == None:
                    # A special case is when the used clicked
                    # the moveto button on the last point in the path.
                    # This indicates a gap (i.e. MOVETO) in the path.
                    self.new = PathElement()
                    if self.moveto == True \
                    or len(self._points) == 0:
                        cmd = MOVETO
                        self.moveto = None
                        self.last_moveto = self.new
                    else:
                        cmd = CURVETO
                    self.new.cmd = cmd
                    self.new.x = x
                    self.new.y = y
                    self.new.ctrl1 = Point(x, y)
                    self.new.ctrl2 = Point(x, y)
                    # Don't forget to map the point's ctrl1 handle
                    # to the ctrl2 handle of the previous point.
                    # This makes for smooth, continuous paths.
                    if len(self._points) > 0:
                        prev = self._points[-1]
                        rx, ry = self.reflect(prev.x, prev.y, prev.ctrl2.x, prev.ctrl2.y)
                        self.new.ctrl1 = Point(rx, ry)
                    self._points.append(self.new)
                else:
                    # Illustrator-like behavior:
                    # when the handle is dragged downwards,
                    # the path bulges upwards.
                    rx, ry = self.reflect(self.new.x, self.new.y, x, y)
                    self.new.ctrl2 = Point(rx, ry)
            
            # Edit mode
            elif self.new == None:
            
                pt = self._points[self.edit]
            
                # The user is pressing the mouse on a point,
                # enter drag-point mode.
                if self.overlap(pt.x, pt.y, x, y) \
                and not self.drag_handle1 \
                and not self.drag_handle2 \
                and not self.new != None:
                    self.drag_point = True
                    self.drag_handle1 = False
                    self.drag_handle2 = False

                # The user is pressing the mouse on a point's handle,
                # enter drag-handle mode.
                if self.overlap(pt.ctrl1.x, pt.ctrl1.y, x, y) \
                and pt.cmd == CURVETO \
                and not self.drag_point \
                and not self.drag_handle2:
                    self.drag_point = False
                    self.drag_handle1 = True
                    self.drag_handle2 = False
                if self.overlap(pt.ctrl2.x, pt.ctrl2.y, x, y) \
                and pt.cmd == CURVETO \
                and not self.drag_point \
                and not self.drag_handle1:
                    self.drag_point = False
                    self.drag_handle1 = False
                    self.drag_handle2 = True
                
                # In drag-point mode,
                # the point is located at the mouse coordinates.
                # The handles move relatively to the new location
                # (e.g. they are retained, the path does not distort).
                # Modify the ctrl1 handle of the next point as well.
                if self.drag_point == True:
                    dx = x - pt.x
                    dy = y - pt.y
                    pt.x = x
                    pt.y = y
                    pt.ctrl2.x += dx
                    pt.ctrl2.y += dy
                    if self.edit < len(self._points)-1:
                        rx, ry = self.reflect(pt.x, pt.y, x, y)
                        next = self._points[self.edit+1]
                        next.ctrl1.x += dx
                        next.ctrl1.y += dy

                # In drag-handle mode,
                # set the path's handle to the mouse location.
                # Rotate the handle of the next or previous point
                # to keep paths smooth - unless the user is pressing "x".
                if self.drag_handle1 == True:
                    pt.ctrl1 = Point(x, y)
                    if self.edit > 0 \
                    and self.last_keycode != 88:
                        prev = self._points[self.edit-1]
                        d = self.distance(prev.x, prev.y, prev.ctrl2.x, prev.ctrl2.y)
                        a = self.angle(prev.x, prev.y, pt.ctrl1.x, pt.ctrl1.y)
                        prev.ctrl2 = self.coordinates(prev.x, prev.y, d, a+180)                        
                if self.drag_handle2 == True:   
                    pt.ctrl2 = Point(x, y)
                    if self.edit < len(self._points)-1 \
                    and self.last_keycode != 88:
                        next = self._points[self.edit+1]
                        d = self.distance(pt.x, pt.y, next.ctrl1.x, next.ctrl1.y)
                        a = self.angle(pt.x, pt.y, pt.ctrl2.x, pt.ctrl2.y)
                        next.ctrl1 = self.coordinates(pt.x, pt.y, d, a+180)
        
        else:
            # The mouse button is released
            # so we are not dragging anything around.
            self.new = None
            self.drag_point = False
            self.drag_handle1 = False
            self.drag_handle2 = False
            
            # The delete button for a point was clicked.
            if self.delete != None and len(self._points) > 0:
                i = self.delete
                cmd = self._points[i].cmd
                del self._points[i]
                if 0 < i < len(self._points):
                    prev = self._points[i-1]
                    rx, ry = self.reflect(prev.x, prev.y, prev.ctrl2.x, prev.ctrl2.y)
                    self._points[i].ctrl1 = Point(rx, ry)
                start_i = i
                while i > 1:
                    i -= 1
                    pt = self._points[i]
                    if i < start_i-1:
                        if pt.cmd == MOVETO:
                            del self._points[i]
                        break
                # When you delete a MOVETO point,
                # the last moveto (the one where the dashed line points to)
                # needs to be updated.
                if len(self._points) > 0 \
                and (cmd == MOVETO or i == 0):
                    self.last_moveto = self._points[0]
                    for pt in self._points:
                        if pt.cmd == MOVETO:
                            self.last_moveto = pt
                self.delete = None
                self.edit = None

            # The moveto button for the last point
            # in the path was clicked.
            elif isinstance(self.moveto, int):
                self.moveto = True
                self.edit = None
            
            # We are not editing a node and
            # the mouse is hovering over the path outline stroke:
            # it is possible to insert a point here.
            elif self.edit == None \
            and self.contains_point(x, y, d=2):
                self.insert = True
            else:
                self.insert = False
            
            # Commit insert of new point.
            if self.inserting \
            and self.contains_point(x, y, d=2): 
                self.insert_point(x, y)
                self.insert = False
            self.inserting = False
        if self.keydown:    
            self.last_keycode = self._keycode
        if not self.keydown and self.last_keycode != None:
            self.last_key = None
            self.last_keycode = None
    
    def draw(self, _ctx):
        
        """ Draws the editable path and interface elements.
        """

        # Enable interaction.
        self.update()
        self.export_svg()
        x, y = self.mouse()
        
        _ctx.strokeWidth = self.strokewidth
        
        r = 4
        _ctx.fillColor = None
        path = Path()
        if len(self._points) > 0:
            first = True
            for i in range(len(self._points)):
                
                # Construct the path.
                pt = self._points[i]
                if first:
                    path.moveto(pt.x, pt.y)
                    first = False
                else:
                    if pt.cmd == CLOSE:
                        path.close()
                    elif pt.cmd == MOVETO:
                        path.moveto(pt.x, pt.y)
                    elif pt.cmd == LINETO:
                        path.lineto(pt.x, pt.y)
                    elif pt.cmd == CURVETO:
                        path.curveto(pt.ctrl1.x, pt.ctrl1.y, 
                                     pt.ctrl2.x, pt.ctrl2.y, 
                                     pt.x, pt.y)
                # In add- or edit-mode,
                # display the current point's handles.
                if ((i == self.edit and self.new == None) \
                or pt == self.new) \
                and pt.cmd == CURVETO:
                    _ctx.strokeColor = self.handle_color
                    _ctx.fillColor = None
                    _ctx.ellipse(pt.x, pt.y, r*2, r*2)
                    _ctx.strokeColor = self.handle_color
                    _ctx.line(pt.ctrl2.x, pt.ctrl2.y, pt.x, pt.y)
                    _ctx.fillColor = self.handle_color
                # Display the new point's handle being dragged.
                if pt == self.new:
                    rx, ry = self.reflect(pt.x, pt.y, pt.ctrl2.x, pt.ctrl2.y)
                    _ctx.strokeColor = self.handle_color
                    _ctx.line(rx, ry, pt.x, pt.y)
                    _ctx.strokeColor = None
                    _ctx.fillColor = self.handle_color
                    _ctx.ellipse(rx, ry, r, r)
                # Display handles for point being edited.
                if i == self.edit \
                and self.new == None \
                and pt.cmd == CURVETO:
                    _ctx.ellipse(pt.ctrl2.x, pt.ctrl2.y, r, r)
                    if i > 0:
                        prev = self._points[i-1]
                        _ctx.line(pt.ctrl1.x, pt.ctrl1.y, prev.x, prev.y)
                        _ctx.ellipse(pt.ctrl1.x, pt.ctrl1.y, r, r)
                    if i > 0 and self._points[i-1].cmd != MOVETO:
                        _ctx.line(prev.ctrl2.x, prev.ctrl2.y, prev.x, prev.y)
                    if i < len(self._points)-1:
                        next = self._points[i+1]
                        if next.cmd == CURVETO:
                            _ctx.line(next.ctrl1.x, next.ctrl1.y, pt.x, pt.y)
                
                # When hovering over a point,
                # highlight it.
                elif self.overlap(x, y, pt.x, pt.y):
                    self.insert = False # quit insert mode
                    _ctx.fillColor = None
                    _ctx.strokeColor = self.handle_color
                    _ctx.ellipse(pt.x, pt.y, r*2, r*2)
                
                if pt.cmd != MOVETO:
                    _ctx.fillColor = self.path_color
                    _ctx.strokeColor = None
                else:
                    _ctx.strokeColor = self.path_color
                    _ctx.fillColor = None
                _ctx.ellipse(pt.x, pt.y, r, r)
                
            # Set the current path,
            self.path = path

            # Possible to insert a point here.
            if self.insert:
                _ctx.strokeColor = self.handle_color
                _ctx.fillColor = None
                _ctx.ellipse(x, y, r*1.6, r*1.6)
                
            # When not editing a node,
            # prospect how the curve will continue
            # when adding a new point.
            if self.edit == None \
            and self.new == None \
            and self.moveto != True:
                _ctx.fillColor = None
                _ctx.strokeColor = self.new_color
                rx, ry = self.reflect(pt.x, pt.y, pt.ctrl2.x, pt.ctrl2.y)
                _ctx.beginPath(pt.x, pt.y)
                _ctx.curveto(rx, ry, x, y, x, y)
                _ctx.endPath()

                # A dashed line indicates what
                # a CLOSETO would look like.
                if self.last_moveto != None:
                    start = self.last_moveto
                else:
                    start = self._points[0]
        
            # When doing a MOVETO,
            # show the new point hovering at the mouse location.
            elif self.edit == None \
            and self.new == None \
            and self.moveto != None:
                _ctx.strokeColor = self.new_color
                _ctx.fillColor = None
                _ctx.ellipse(x, y, r*1.6, r*1.6)
            
            # Draws button for a point being edited.
            # The first button deletes the point.
            # The second button, which appears only on the last point
            # in the path, tells the editor to perform a MOVETO
            # before adding a new point.
            if self.edit != None:
                pt = self._points[self.edit]
                x = pt.x + self.btn_x
                y = pt.y + self.btn_y
                r = self.btn_r
                _ctx.strokeColor = None
                _ctx.fillColor = Color(0, 0, 0, 0.2)
                _ctx.fillColor = self.handle_color
                _ctx.ellipse(x, y, r*2, r*2)
                _ctx.fillColor = Color(1, 1, 1)
                _ctx.rotate(45)
                _ctx.rect(x, y, r+1, 1.25)
                _ctx.rotate(-90)
                _ctx.rect(x, y, r+1, 1.25)
                _ctx.reset()
                if self.edit == len(self._points)-1:
                    _ctx.fillColor = self.handle_color
                    _ctx.ellipse(x+r*2+2, y, r*2, r*2)
                    _ctx.fillColor = Color(1, 1, 1)
                    _ctx.rect(x+r*2+3-2.25, y, 1.5, r-1)
                    _ctx.rect(x+r*2+3+0.75, y, 1.5, r-1)
        
    def import_svg(self):
        self.path_string = self.node.asString("path")                
        s = template_svg % self.path_string
        self.path = svg.parse(s)[0]
        self._points = []
        for contour in self.path.contours:
            if not (len(contour.points) == 1 and contour.points[0].x == 0 and contour.points[0].y == 0):
                first = None
                curvePoint = PathElement()
                curvePoint.cmd = CURVETO
                first_curvepoint = True
                for point in contour.points:
                    if first is None or point.isLineTo():
                        pe = PathElement()
                        if first is None:
                            first = point
                            pe.cmd = MOVETO
                        else:
                            pe.cmd = LINETO
                        pe.x = point.x
                        pe.y = point.y
                        self._points.append(pe)
                    else:
                        if first_curvepoint:
                            curvePoint.ctrl1.x = point.x
                            curvePoint.ctrl1.y = point.y
                            first_curvepoint = False
                        elif point.isOffCurve():
                            curvePoint.ctrl2.x = point.x
                            curvePoint.ctrl2.y = point.y
                        else:
                            curvePoint.x = point.x
                            curvePoint.y = point.y
                            self._points.append(curvePoint)
                            curvePoint = PathElement()
                            curvePoint.cmd = CURVETO
                            first_curvepoint = True
                if contour.closed:
                    pe = PathElement()
                    pe.cmd = CLOSE  
                    self._points.append(pe)    

    def export_svg(self):
        s = ""
        if len(self._points) > 0:
            for pt in self._points:
                if pt.cmd == MOVETO:
                    s += "M "+str(pt.x)+" "+str(pt.y)+" "
                elif pt.cmd == LINETO:
                    s += "L "+str(pt.x)+" "+str(pt.y)+" "
                elif pt.cmd == CURVETO:
                    s += "C "
                    s += str(pt.ctrl1.x)+" "+str(pt.ctrl1.y)+" "
                    s += str(pt.ctrl2.x)+" "+str(pt.ctrl2.y)+" "
                    s += str(pt.x)+" "+str(pt.y)+" "
            self.path_string = s
            if self.path_string != self.node.asString("path"):
                self.node.silentSet("path", s)
    
    def mouse(self):
        if self._mouseXY is not None:
            return (self._mouseXY.x, self._mouseXY.y)
        else:
            return (0, 0)

    def mousePressed(self, pt):
        self._mouseXY = pt
        self.mousedown = True
        self.node.markDirty()
        
    def mouseDragged(self, pt):
        self._mouseXY = pt
        self.node.markDirty()

    def mouseReleased(self, pt):
        self._mouseXY = pt
        self.mousedown = False
        self.node.markDirty()
    
    def mouseMoved(self, pt):
        self._mouseXY = pt
        self.viewer.repaint()

    def keyPressed(self, keycode, modifiers):
        self._keycode = keycode
        self.keydown = True
        self.viewer.repaint()

    def keyReleased(self, keycode, modifiers):
        self._keycode = keycode
        self.keydown = False
        self.viewer.repaint()

def cook(self):
    return BezierPathEditor(self.node)]]></value>
    </param>
    <param name="_image">
      <value>curve.png</value>
    </param>
    <param name="path" type="string">
      <value/>
    </param>
    <param name="fill" type="color">
      <value>#00000000</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>1.0</value>
    </param>
  </node>
  <node name="edit" prototype="filter" x="330" y="250">
    <description>Edit points non-destructively.</description>
    <param name="_code">
      <value type="python"><![CDATA[def _string_to_dict(s):
    d = {}
    for el in s.split("P"):
        if el:
            item = el.strip().split(" ")
            try:
                index = int(item[0])
                x = float(item[1])
                y = float(item[2])
                d[index] = (x, y)
            except:
                pass
    return d

def cook(self):
    if self.shape is None: return None
    new_shape = self.shape.clone()
    points = new_shape.points
    if self.pointDeltas:
        deltas = _string_to_dict(self.pointDeltas)
        for index in deltas.keys():
            try:
                point = deltas[index]
                points[index].x += point[0]
                points[index].y += point[1]
            except IndexError:
                pass
    return new_shape]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Color, IGeometry
from nodebox.handle import AbstractHandle

class EditHandle(AbstractHandle):
    def __init__(self, node):
        AbstractHandle.__init__(self, node)
        self.shape = None
        self.points = []
        self._selected_point = -1
        self._edited_as_string = ""
        # When we move a curve point that has control points,
        # we want those handles too move the same amount.
        # _delta_prev and _delta_next are the horizontal and vertical 
        # distance from those control points to the point.
        self._delta_prev = None         
        self._delta_next = None
        self.update()

    def update(self):
        shape = self.node.getPort("shape").value
        same_shape = self.shape == shape
        if not same_shape:
            self.shape = shape
            self.points = []
            if isinstance(self.shape, IGeometry):
                self.points = self.shape.clone().points

        deltas = self.node.asString("pointDeltas")
        
        if not same_shape or self._edited_as_string != deltas:
            self._edited_points = {}
            delta_values = deltas and self._string_to_dict(deltas) or {}
            for (key, (x, y)) in delta_values.items():
                try:
                    point = self.points[key]
                    self._edited_points[key] = (x + point.x, y + point.y)
                except IndexError:
                    self._edited_points[key] = (x, y)
        
        self.visible = isinstance(self.shape, IGeometry)
                
    def mousePressed(self, pt):
        keys = self._edited_points.keys()
        num_points = len(self.points)
        
        for index, point in enumerate(self.points):
            if index in keys:
                x, y = self._edited_points[index]
            else:
                x, y = point.x, point.y

            if self.createHitRectangle(x, y).contains(pt):
                self._selected_point = index

                if self.points[index].isCurveTo():
                    i_p = index - 1
                    if i_p > 0 and self.points[i_p].isOffCurve():
                        if i_p in keys:
                            x1, y1 = self._edited_points[i_p]
                        else:
                            point = self.points[i_p]
                            x1, y1 = point.x, point.y
                        self._delta_prev = (x - x1, y - y1)
                    i_n = index + 1
                    if i_n < num_points and self.points[i_n].isOffCurve():
                        if i_n in keys:
                            x1, y1 = self._edited_points[i_n]
                        else:
                            point = self.points[i_n]
                            x1, y1 = point.x, point.y
                        self._delta_next = (x - x1, y - y1)
                break

    def mouseDragged(self, pt):
        if self._selected_point != -1:
            self._edited_points[self._selected_point] = (pt.x, pt.y)
            if self._delta_prev is not None:
                dx, dy = self._delta_prev
                self._edited_points[self._selected_point - 1] = (pt.x - dx, pt.y - dy)
            if self._delta_next is not None:
                dx, dy = self._delta_next
                self._edited_points[self._selected_point + 1] = (pt.x - dx, pt.y - dy)
            self.updateValues()            

    def _dict_to_string(self, d):
        items = d.items()
        items.sort()
        s = ""
        for item in items:
            index, (x, y) = item
            s += "P %d %.3f %.3f " % (index, x, y)
        return s[:-1]

    def _string_to_dict(self, s):
        d = {}
        for el in s.split("P"):
            if el:
                item = el.strip().split(" ")
                try:
                    index = int(item[0])
                    x = float(item[1])
                    y = float(item[2])
                    d[index] = (x, y)
                except:
                    pass
        return d
        
    def updateValues(self):
        delta_values = {}
        for (index, (x, y)) in self._edited_points.items():
            try:
                point = self.points[index]
                delta_values[index] = (x - point.x, y - point.y)
            except IndexError:
                delta_values[index] = (x, y)
        self._edited_as_string = self._dict_to_string(delta_values)
        self.node.silentSet("pointDeltas", self._edited_as_string)
            
    def mouseReleased(self, pt):
        self._selected_point = -1
        self._delta_prev = None
        self._delta_next = None

    def draw(self, ctx):
        self._draw_points(ctx, True, AbstractHandle.HANDLE_COLOR)
        self._draw_points(ctx, False, Color(1, 1, 1))

    def _draw_points(self, ctx, on_curve, color):
        keys = self._edited_points.keys()
        for index, point in enumerate(self.points):
            if on_curve and point.isOnCurve() or point.isOffCurve():
                if index in keys:
                    x, y = self._edited_points[index]
                else:
                    x, y = point.x, point.y
                path = Path()
                path.fillColor = color
                path.strokeWidth = 0

                if not on_curve:
                    path.strokeColor = Color(.3, .3, .3)
                    path.strokeWidth = 1

                self.drawDot(path, x, y)
                ctx.draw(path)
                
                if not on_curve:
                    if index - 1 in keys:
                        prev_point = self._edited_points[index - 1]
                    else: 
                        point = self.points[index-1]
                        prev_point = (point.x, point.y)
                    
                    if index + 1 in keys:
                        next_point = self._edited_points[index + 1]
                    else:
                        point = self.points[index+1]
                        next_point = (point.x, point.y)
                    path = Path()
                    path.moveto(x, y)
                    if self.points[index - 1].isOnCurve():
                        path.lineto(prev_point[0], prev_point[1])
                    else:
                        path.lineto(next_point[0], next_point[1])
                    path.strokeColor = Color(0, 0, 1)
                    path.strokeWidth = 1
                    ctx.draw(path)
 
def cook(self):
    return EditHandle(self.node)]]></value>
    </param>
    <param help="" name="_image">
      <value>edit.png</value>
    </param>
    <param name="pointDeltas" type="string">
      <value/>
    </param>
  </node>
  <node name="ellipse" prototype="generator" x="90" y="90">
    <description>Create ellipses and circles.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    p = Path()
    p.ellipse(self.x, self.y, self.width, self.height)
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.asGeometry()]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import FourPointHandle

def cook(self):
    return FourPointHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>ellipse.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>100.0</value>
    </param>
    <param name="height" type="float">
      <value>100.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="fit" prototype="filter" x="410" y="250">
    <description>Fit a shape within bounds.</description>
    <port name="template"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Transform

def cook(self):
    if self.shape is None: return None

    px, py, pw, ph = list(self.shape.bounds)

    # if a template shape is given, use its bounding rectangle,
    # otherwise use the input values.
    if self.template is not None:
        x, y, width, height = list(self.template.bounds)
        x += width / 2
        y += height / 2
    else:
        x = self.x
        y = self.y
        width = self.width
        height = self.height

    t = Transform()
    t.translate(x, y)
    t.scale(width / pw, height / ph)
    t.translate(-pw / 2 - px, -ph / 2 - py)

    return t.map(self.shape)]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import FourPointHandle

class FitHandle(FourPointHandle):
    def __init__(self, *args):
        FourPointHandle.__init__(self, *args)
        self.update()
    
    def update(self):
        shape = self.node.getPort("shape").value
        template = self.node.getPort("template").value
        self.visible = not (shape is None or template is not None)

def cook(self):
    return FitHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>fit.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>300.0</value>
    </param>
    <param name="height" type="float">
      <value>300.0</value>
    </param>
  </node>
  <node name="geonet" prototype="builtins.root" rendered="true" type="nodebox.graphics.Geometry" x="10" y="10">
    <description>A network of geometry nodes.</description>
    <param name="_image">
      <value>geonet.png</value>
    </param>
  </node>
  <node name="grid" prototype="generator" x="170" y="90">
    <description>Create a grid of points.</description>
    <param name="_code">
      <value type="python"><![CDATA[
from nodebox.graphics import Path

def cook(self):
    p = Path()
    p.fill = None
    column_size = 0
    left = 0
    if self.columns > 1:
        column_size = self.width / (self.columns - 1)
        left = self.x - self.width / 2
    row_size = 0
    top = 0
    if self.rows > 1:
        row_size = self.height / (self.rows - 1)
        top = self.y - self.height / 2
    for ri in xrange(self.rows):
        for ci in xrange(self.columns):
            p.addPoint(left + ci * column_size, top + ri * row_size)
    return p.asGeometry()]]></value>
    </param>
    <param name="_image">
      <value>grid.png</value>
    </param>
    <param help="" name="width" type="float">
      <value>300.0</value>
    </param>
    <param name="height" type="float">
      <value>300.0</value>
    </param>
    <param name="rows" type="int">
      <value>10</value>
    </param>
    <param name="columns" type="int">
      <value>10</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="import" prototype="generator" x="250" y="90">
    <description>Import geometry from a SVG file.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Geometry, Transform

def cook(self):
    if not self.file: return None
    f = file(self.file, 'r')
    s = f.read()
    f.close()
    g = Geometry()
    # We defer loading the SVG library until we need it.
    # This makes creating a node faster.
    import svg
    paths = svg.parse(s)
    for path in paths:
        g.add(path)
    t = Transform()
    if self.centered:
        x, y, w, h = list(g.bounds)
        t.translate(-x-w/2, -y-h/2)
    t.translate(self.x, self.y)
    g = t.map(g)
    return g
]]></value>
    </param>
    <param name="_image">
      <value>import.png</value>
    </param>
    <param name="file" type="string" widget="file">
      <value/>
    </param>
    <param label="Center on canvas" name="centered" type="int" widget="toggle">
      <value>1</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="line" prototype="generator" x="170" y="170">
    <description>Draw a line between two points.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path
from nodebox.util.Geometry import coordinates

def cook(self):
    p = Path()
    x1, y1 = coordinates(self.x, self.y, self.distance, self.angle)
    p.line(self.x, self.y, x1, y1)
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    p = p.resampleByAmount(self.points, True)
    return p.asGeometry()]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.graphics import Path
from nodebox.handle import AbstractHandle
from nodebox.util.Geometry import coordinates, angle, distance

class LineHandle(AbstractHandle):
  NONE, ORIGIN, MIDDLE, END = range(4)

  def __init__(self, node):
      AbstractHandle.__init__(self, node)
      self.dragState = LineHandle.NONE

  def draw(self, ctx):
      cx = self.node.asFloat("x")
      cy = self.node.asFloat("y")
      cornerPath = Path()
      cornerPath.fillColor = AbstractHandle.HANDLE_COLOR
      self.drawDot(cornerPath, cx, cy)
      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance"), self.node.asFloat("angle"))
      self.drawDot(cornerPath, x1, y1)
      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance") / 2, self.node.asFloat("angle"))
      self.drawDot(cornerPath, x1, y1)
      ctx.canvas.add(cornerPath)

  def mousePressed(self, pt):
      self.px = pt.x
      self.py = pt.y

      cx = self.ocx = self.node.asFloat("x")
      cy = self.ocy = self.node.asFloat("y")
      origin = self.createHitRectangle(cx, cy)

      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance"), self.node.asFloat("angle"))
      end = self.createHitRectangle(x1, y1)

      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance") / 2, self.node.asFloat("angle"))
      middle = self.createHitRectangle(x1, y1)

      if origin.contains(pt):
          self.dragState = self.ORIGIN
      elif end.contains(pt):
          self.dragState = self.END
      elif middle.contains(pt):
          self.dragState = self.MIDDLE
      else:
          self.dragState = self.NONE

  def mouseDragged(self, pt):
      if self.dragState == self.NONE: return

      x = pt.x
      y = pt.y
      dx = x - self.px
      dy = y - self.py

      if (dx == 0 and dy == 0): return

      if self.dragState == self.MIDDLE:
          self.node.silentSet("x", self.ocx + dx)
          self.node.silentSet("y", self.ocy + dy)
      elif self.dragState == self.ORIGIN:
          x1, y1 = coordinates(self.node.asFloat("x"), self.node.asFloat("y"), self.node.asFloat("distance"), self.node.asFloat("angle"))
          a = angle(x, y, x1, y1)
          d = distance(x, y, x1, y1)
          self.node.silentSet("x", x)
          self.node.silentSet("y", y)
          self.node.silentSet("angle", a)
          self.node.silentSet("distance", d)
      elif self.dragState == self.END:
          a = angle(self.ocx, self.ocy, x, y)
          d = distance(self.ocx, self.ocy, x, y)
          self.node.silentSet("angle", a)
          self.node.silentSet("distance", d)

  def mouseReleased(self, pt):
      self.dragState = self.NONE


def cook(self):
  return LineHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>line.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="angle" type="float" widget="angle">
      <value>0.0</value>
    </param>
    <param name="distance" type="float">
      <value>120.0</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>1.0</value>
    </param>
    <param bounding="hard" min="2.0" name="points" type="int">
      <value>2</value>
    </param>
  </node>
  <node name="merge" prototype="generator" x="90" y="330">
    <description>Combine multiple geometries together.</description>
    <port cardinality="multiple" name="shapes"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Geometry

def cook(self):
  g = Geometry()
  if self.shapes is None: return g
  for shape in self.shapes:
      g.extend(shape)
  return g]]></value>
    </param>
    <param name="_image">
      <value>merge.png</value>
    </param>
  </node>
  <node name="null" prototype="filter" x="170" y="330">
    <description>Does nothing.</description>
    <param name="_code">
      <value type="python"><![CDATA[def cook(self):
    return self.shape]]></value>
    </param>
    <param help="" name="_image">
      <value>null.png</value>
    </param>
  </node>
  <node name="place" prototype="filter" x="250" y="330">
    <port name="template"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.node import StampExpression
from nodebox.graphics import Path, Geometry, Transform

def cook(self):
  if self.shape is None: return None
  if self.template is None: return self.shape.clone()

  if self.stamp:
      stamp = StampExpression(self.node, "expr")
  g = Geometry()
  for i, point in enumerate(self.template.points):
      if self.stamp:
          context.put('CNUM', i)
          stamp.evaluate(context)
          self.node.stampExpressions(context)
      t = Transform()
      t.translate(point.x, point.y)
      newShape = t.map(self.shape)
      g.extend(newShape)
  return g]]></value>
    </param>
    <param name="_image">
      <value>place.png</value>
    </param>
    <param label="Copy Stamping" name="stamp" type="int" widget="toggle">
      <value>0</value>
    </param>
    <param label="Expression" name="expr" type="string" widget="stamp_expression">
      <value/>
    </param>
  </node>
  <node name="polygon" prototype="generator" x="250" y="170">
    <description>Draw a polygon</description>
    <param name="_code">
      <value type="python"><![CDATA[from math import cos, sin, pi
from nodebox.graphics import Path, Transform
from nodebox.util.Geometry import angle

def cook(self):
    t = 0
    vertices = []
    vertices.append((self.x + cos(t) * self.radius, self.y + sin(t) * self.radius))
    p = Path()
    p.moveto( *vertices[0] )
    for i in range(1, self.sides):               
        t += 2*pi/self.sides
        vertices.append((self.x + cos(t) * self.radius, self.y + sin(t) * self.radius))
        p.lineto( *vertices[i] ) 
    p.close()
    if self.align and len(vertices) >= 2:
        (x1, y1), (x2, y2) = vertices[0:2]
        a = angle(x2, y2, x1, y1)
        t = Transform()
        t.rotate(-a)
        p = t.map(p)
    p.fillColor = self.fill
    p.strokeColor = self.stroke
    p.strokeWidth = self.strokeWidth
    return p.asGeometry()]]></value>
    </param>
    <param name="_image">
      <value>polygon.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param bounding="hard" min="0.0" name="radius" type="float">
      <value>100.0</value>
    </param>
    <param bounding="hard" min="0.0" name="sides" type="int">
      <value>3</value>
    </param>
    <param name="align" type="int" widget="toggle">
      <value>0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" min="0.0" name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="rect" prototype="generator" x="330" y="90">
    <description>Create rectangles and rounded rectangles.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    p = Path()
    if self.rx == 0 and self.ry == 0:
        p.rect(self.x, self.y, self.width, self.height)
    else:
        p.roundedRect(self.x, self.y, self.width, self.height, self.rx, self.ry)
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.asGeometry()]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import FourPointHandle

def cook(self):
    return FourPointHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>rect.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>100.0</value>
    </param>
    <param name="height" type="float">
      <value>100.0</value>
    </param>
    <param label="Roundness X" name="rx" type="float">
      <value>0.0</value>
    </param>
    <param label="Roundness Y" name="ry" type="float">
      <value>0.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="resample" prototype="filter" x="330" y="330">
    <description>Distribute points along a shape.</description>
    <param name="_code">
      <value type="python"><![CDATA[
def cook(self):
    # Check if a shape is connected.
    if self.shape is None: return None
    if self.method == 'length':
        return self.shape.resampleByLength(self.length)
    else:
        return self.shape.resampleByAmount(self.points, self.perContour)]]></value>
    </param>
    <param name="_image">
      <value>resample.png</value>
    </param>
    <param name="method" type="string" widget="menu">
      <value>length</value>
      <menu key="length">By Length</menu>
      <menu key="amount">By Amount</menu>
    </param>
    <param bounding="hard" min="0.01" name="length" type="float">
      <value>10.0</value>
    </param>
    <param bounding="hard" min="1.0" name="points" type="int">
      <value>10</value>
    </param>
    <param label="Per Contour" name="perContour" type="int" widget="toggle">
      <value>0</value>
    </param>
  </node>
  <node name="scatter" prototype="filter" x="410" y="330">
    <description>Generate points within the boundaries of a shape.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Point
from random import seed, uniform

def cook(self):
    seed(self.seed)
    if self.shape is None: return None
    bx, by, bw, bh = list(self.shape.bounds)
    p = Path()
    for i in xrange(self.amount):
        tries = 100
        while tries > 0:
            pt = Point(bx + uniform(0, 1) * bw, by + uniform(0, 1) * bh)
            if self.shape.contains(pt):
                break
            tries -= 1
        if tries:
            p.moveto(pt.x, pt.y)
        else:
            pass # add warning: no points found on the path

    return p.asGeometry()]]></value>
    </param>
    <param name="_image">
      <value>scatter.png</value>
    </param>
    <param bounding="hard" min="0.0" name="amount" type="int">
      <value>20</value>
    </param>
    <param bounding="hard" min="0.0" name="seed" type="int">
      <value>0</value>
    </param>
  </node>
  <node name="star" prototype="generator" x="410" y="90">
    <description>Create a star shape.</description>
    <param name="_code">
      <value type="python"><![CDATA[from math import pi, sin, cos
from nodebox.graphics import Path

def cook(self):
    p = Path()
    p.moveto(self.x, self.y + self.outer / 2)

    for i in xrange(1, self.points * 2):
        angle = i * pi / self.points
        x = sin(angle)
        y = cos(angle)
        radius = i % 2 and self.inner / 2 or self.outer / 2
        x = self.x + radius * x
        y = self.y + radius * y
        p.lineto(x, y)
    p.close()
    p.fill = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    # Convert the path to a geometry object and return.
    return p.asGeometry()]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import AbstractHandle, FourPointHandle

class StarHandle(AbstractHandle):
  def __init__(self, node):
      AbstractHandle.__init__(self, node)
      self.innerHandle = FourPointHandle(node, "x", "y", "inner", "inner")
      self.outerHandle = FourPointHandle(node, "x", "y", "outer", "outer")

  def draw(self, ctx):
      self.innerHandle.draw(ctx)
      self.outerHandle.draw(ctx)

  def mousePressed(self, pt):
      inner, outer = self.innerHandle, self.outerHandle

      if self.node.asFloat("inner") > self.node.asFloat("outer"):
          inner, outer = outer, inner

      inner.mousePressed(pt)
      if not inner.hasDragState():
          outer.mousePressed(pt)

  def mouseDragged(self, pt):
      inner, outer = self.innerHandle, self.outerHandle

      if self.node.asFloat("inner") > self.node.asFloat("outer"):
          inner, outer = outer, inner

      inner.mouseDragged(pt)
      if not inner.hasDragState():
          outer.mouseDragged(pt)

  def mouseReleased(self, pt):
      self.innerHandle.mouseReleased(pt)
      self.outerHandle.mouseReleased(pt)

def cook(self):
  return StarHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>star.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param bounding="hard" min="1.0" name="points" type="int">
      <value>20</value>
    </param>
    <param name="outer" type="float">
      <value>200.0</value>
    </param>
    <param name="inner" type="float">
      <value>100.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="textpath" prototype="generator" x="90" y="170">
    <description>Create a path out of text.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Text

def cook(self):
    t = Text(self.text, self.x, self.y, self.width, self.height)
    t.fontName = self.font
    t.fontSize = self.size
    # valueOf requires a correct value: LEFT, CENTER, RIGHT or JUSTIFY. Anything else will
    # make it crash. If users start doing crazy things and change the alignment, at least
    # make sure you catch the error.
    try:
        t.align = Text.Align.valueOf(self.align)
    except:
        pass
    p = t.path
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.asGeometry()]]></value>
    </param>
    <param name="_image">
      <value>textpath.png</value>
    </param>
    <param name="text" type="string">
      <value>hello</value>
    </param>
    <param name="font" type="string" widget="font">
      <value>Verdana</value>
    </param>
    <param name="size" type="float">
      <value>24.0</value>
    </param>
    <param name="align" type="string" widget="menu">
      <value>CENTER</value>
      <menu key="LEFT">Left</menu>
      <menu key="CENTER">Center</menu>
      <menu key="RIGHT">Right</menu>
      <menu key="JUSTIFY">Justify</menu>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>0.0</value>
    </param>
    <param name="height" type="float">
      <value>0.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param bounding="hard" label="Stroke Width" min="0.0" name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="transform" prototype="filter" x="90" y="410">
    <description>Transforms the location, rotation and scale of a shape.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Transform

def cook(self):
    if self.shape is None: return None
    t = Transform()
    # Each letter of the order describes an operation.
    for op in self.order:
        if op == 't':
            t.translate(self.tx, self.ty)
        elif op == 'r':
            t.rotate(self.r)
        elif op == 's':
            t.scale(self.sx / 100, self.sy / 100)
    # Transform.map clones and transforms the geometry.
    return t.map(self.shape)]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import PointHandle

def cook(self):
    return PointHandle(self.node, "tx", "ty")]]></value>
    </param>
    <param name="_image">
      <value>transform.png</value>
    </param>
    <param name="order" type="string" widget="menu">
      <value>tsr</value>
      <menu key="srt">Scale Rot Trans</menu>
      <menu key="str">Scale Trans Rot</menu>
      <menu key="rst">Rot Scale Trans</menu>
      <menu key="rts">Rot Trans Scale</menu>
      <menu key="tsr">Trans Scale Rot</menu>
      <menu key="trs">Trans Rot Scale</menu>
    </param>
    <param label="Translate X" name="tx" type="float">
      <value>0.0</value>
    </param>
    <param label="Translate Y" name="ty" type="float">
      <value>0.0</value>
    </param>
    <param label="Rotate" name="r" type="float">
      <value>0.0</value>
    </param>
    <param label="Scale X" name="sx" type="float">
      <value>100.0</value>
    </param>
    <param label="Scale Y" name="sy" type="float">
      <value>100.0</value>
    </param>
  </node>
  <node name="wiggle" prototype="filter" x="170" y="410">
    <description>Shift points by a random amount.</description>
    <param name="_code">
      <value type="python"><![CDATA[from random import seed, uniform

def cook(self):
    seed(self.seed)
    if self.shape is None: return None
    new_shape = self.shape.clone()
    for point in new_shape.points:
        dx = (uniform(0, 1) - 0.5) * self.wx * 2
        dy = (uniform(0, 1) - 0.5) * self.wy * 2
        point.x += dx
        point.y += dy
    return new_shape]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import PointHandle

class WiggleHandle(PointHandle):
    def __init__(self, *args):
        PointHandle.__init__(self, *args)
        self.update()
    
    def update(self):
        shape = self.node.getPort("shape").value
        self.visible = shape is not None

def cook(self):
    return WiggleHandle(self.node, "wx", "wy")]]></value>
    </param>
    <param name="_image">
      <value>wiggle.png</value>
    </param>
    <param label="Wiggle X" name="wx" type="float">
      <value>30.0</value>
    </param>
    <param label="Wiggle Y" name="wy" type="float">
      <value>30.0</value>
    </param>
    <param bounding="hard" min="0.0" name="seed" type="int" widget="seed">
      <value>0</value>
    </param>
  </node>
</ndbx>
