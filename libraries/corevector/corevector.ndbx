<?xml version="1.0" encoding="UTF-8"?>
<ndbx type="file" formatVersion="0.9">
  <node name="ellipse" prototype="builtins.root" x="230" y="30" type="nodebox.graphics.Grob">
  <description>Creates ellipses and circles.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    p = Path()
    p.ellipse(self.x, self.y, self.width, self.height)
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p]]></value>
    </param>
    <param name="_image">
      <value>ellipse.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>100.0</value>
    </param>
    <param name="height" type="float">
      <value>100.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="transform" prototype="builtins.root" x="230" y="200" type="nodebox.graphics.Grob">
  <description>Transforms the location, rotation and scale of a shape.</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Transform

def cook(self):
    if self.shape is None: return None
    t = Transform()
    # Each letter of the order describes an operation.
    for op in self.order:
        if op == 't':
            t.translate(self.tx, self.ty)
        elif op == 'r':
            t.rotate(self.r)
        elif op == 's':
            t.scale(self.sx / 100, self.sy / 100)
    newShape = self.shape.clone()
    newShape.transform(t)
    return newShape]]></value>
    </param>
    <param name="order" type="string" widget="menu">
      <value>tsr</value>
      <menu key="srt">Scale Rot Trans</menu>
      <menu key="str">Scale Trans Rot</menu>
      <menu key="rst">Rot Scale Trans</menu>
      <menu key="rts">Rot Trans Scale</menu>
      <menu key="tsr">Trans Scale Rot</menu>
      <menu key="trs">Trans Rot Scale</menu>
    </param>
    <param name="tx" type="float" label="Translate X">
      <value>0.0</value>
    </param>
    <param name="ty" type="float" label="Translate Y">
      <value>0.0</value>
    </param>
    <param name="r" type="float" label="Rotate">
      <value>0.0</value>
    </param>
    <param name="sx" type="float" label="Scale X">
      <value>100.0</value>
    </param>
    <param name="sy" type="float" label="Scale Y">
      <value>100.0</value>
    </param>
  </node>
  <node name="copy" prototype="builtins.root" x="140" y="110" type="nodebox.graphics.Grob">
  <description>Creates multiple copies of the input.</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Group, Transform

def cook(self):
    if self.shape is None:
        return None
    g = Group()
    tx = ty = r = 0.0
    sx = sy = 1.0
    for i in range(self.copies):
        t = Transform()
        # Each letter of the order describes an operation.
        for op in self.order:
            if op == 't':
                t.translate(tx, ty)
            elif op == 'r':
                t.rotate(r)
            elif op == 's':
                t.scale(sx, sy)
        newShape = self.shape.clone()
        newShape.transform(t)
#        if isinstance(newShape, Group):
        try:
            g.extend(newShape)
#        else:
        except:
            g.add(newShape)
        tx += self.tx
        ty += self.ty
        r += self.r
        sx += self.sx / 100.0
        sy += self.sy / 100.0
    return g]]></value>
    </param>
    <param name="_image">
      <value>copy.png</value>
    </param>
    <param name="copies" type="int">
      <value>1</value>
    </param>
    <param name="order" type="string" widget="menu">
      <value>tsr</value>
      <menu key="srt">Scale Rot Trans</menu>
      <menu key="str">Scale Trans Rot</menu>
      <menu key="rst">Rot Scale Trans</menu>
      <menu key="rts">Rot Trans Scale</menu>
      <menu key="tsr">Trans Scale Rot</menu>
      <menu key="trs">Trans Rot Scale</menu>
    </param>
    <param name="tx" type="float" label="Translate X">
      <value>0.0</value>
    </param>
    <param name="ty" type="float" label="Translate Y">
      <value>0.0</value>
    </param>
    <param name="r" type="float" label="Rotate">
      <value>0.0</value>
    </param>
    <param name="sx" type="float" label="Scale X">
      <value>0.0</value>
    </param>
    <param name="sy" type="float" label="Scale Y">
      <value>0.0</value>
    </param>
  </node>
  <node name="textpath" prototype="builtins.root" x="410" y="110" type="nodebox.graphics.Grob">
  <description>Creates a textpath based on an input.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path,Text

def cook(self):
    t = Text(self.text, self.x, self.y, self.width, self.height)
    t.fontName = self.font
    t.fontSize = self.size
    p = t.path
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p]]></value>
    </param>
    <param name="_image">
      <value>tp.png</value>
    </param>
    <param name="text" type="string">
      <value>word</value>
    </param>
    <param name="x" type="float">
      <value>-35.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>0.0</value>
    </param>
    <param name="height" type="float">
      <value>0.0</value>
    </param>
    <param name="font" type="string" widget="font">
      <value>Futura-Medium</value>
    </param>
    <param name="fill" type="color">
      <value>#00000000</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="size" type="float">
      <value>105.0</value>
    </param>
    <param name="strokeWidth" type="float">
      <value>3.0</value>
    </param>
  </node>
  <node name="scatter" prototype="builtins.root" x="140" y="200" type="nodebox.graphics.Grob">
  <description>Generates points within shape boundaries</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Point
from random import seed, uniform

def cook(self):
    seed(self.seed)
    if self.shape is None: return None
    bx, by, bw, bh = list(self.shape.bounds)
    p = Path()
    for i in xrange(self.amount):
        tries = 100
        while tries > 0:
            pt = Point(bx + uniform(0, 1) * bw, by + uniform(0, 1) * bh)
            if self.shape.contains(pt):
                break
            tries -= 1
        if tries:
            p.moveto(pt.x, pt.y)
        else:
            pass # add warning: no points found on the path

    return p]]></value>
    </param>
    <param name="_image">
      <value>scatter.png</value>
    </param>
    <param name="amount" type="int" bounding="hard" min="0.0">
      <value>20</value>
    </param>
    <param name="seed" type="int" bounding="hard" min="0.0">
      <value>0</value>
    </param>
  </node>
  <node name="grid" prototype="builtins.root" x="320" y="110" type="nodebox.graphics.Grob">
  <description>Creates a grid of points.</description>
    <param name="_code">
      <value type="python"><![CDATA[
from nodebox.graphics import Path

def cook(self):
    p = Path()
    p.fill = None
    column_size = 0
    left = 0
    if self.columns > 1:
        column_size = self.width / (self.columns - 1)
        left = self.x - self.width / 2
    row_size = 0
    top = 0
    if self.rows > 1:
        row_size = self.height / (self.rows - 1)
        top = self.y - self.height / 2
    for ri in xrange(self.rows):
        for ci in xrange(self.columns):
            p.addPoint(left + ci * column_size, top + ri * row_size)
    return p]]></value>
    </param>
    <param name="_image">
      <value>grid.png</value>
    </param>
    <param name="width" type="float" help="">
      <value>300.0</value>
    </param>
    <param name="height" type="float">
      <value>300.0</value>
    </param>
    <param name="rows" type="int">
      <value>10</value>
    </param>
    <param name="columns" type="int">
      <value>10</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="filter" prototype="builtins.root" x="50" y="110" type="nodebox.graphics.Grob">
  <description>Template for creating nodes that manipulate vector data.</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[# This node serves as a template for writing your own vector filters.
# Read the code in cook() and replace it with your own.
from nodebox.graphics import Path

def cook(self):
    # Replace the code below
    # Check if a shape is connected.
    if self.shape is None: return None
    # If you're changing the shape, make sure to clone it.
    clone = self.shape.clone()
    # Do something with the cloned copy.
    clone.rotate(45)
    # Return the transformed shape.
    return clone]]></value>
    </param>
    <param name="_image">
      <value>filter.png</value>
    </param>
  </node>
  <node name="null" prototype="builtins.root" x="140" y="290">
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[def cook(self):
    return self.shape]]></value>
    </param>
  </node>
  <node name="color" prototype="builtins.root" x="50" y="200" type="nodebox.graphics.Grob">
  <description>Color the input shapes.</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    if self.shape is None: return None
    clone = self.shape.clone()
    clone.fillColor = self.fill
    if self.strokeWidth > 0:
        clone.strokeColor = self.stroke
        clone.strokeWidth = self.strokeWidth
    else:
        clone.strokeColor = None
    return clone]]></value>
    </param>
    <param name="_image">
      <value>color.png</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float" label="Stroke Width" bounding="hard" min="0.0">
      <value>0.0</value>
    </param>
  </node>
  <node name="star" prototype="builtins.root" x="410" y="30" type="nodebox.graphics.Grob">
  <description>Creates a star.</description>
    <param name="_code">
      <value type="python"><![CDATA[# This node serves as a template for writing your own vector generators.
# Read the code in cook and replace it with your own.
from math import pi, sin, cos
from nodebox.graphics import Path

def cook(self):
    p = Path()
    p.moveto(self.x, self.y + self.outer / 2)

    for i in xrange(1, self.points * 2):
        angle = i * pi / self.points
        x = sin(angle)
        y = cos(angle)
        radius = i % 2 and self.inner / 2 or self.outer / 2
        x = self.x + radius * x
        y = self.y + radius * y
        p.lineto(x, y)
    p.close()
    p.fill = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    # Return the path object.
    return p]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import AbstractHandle, FourPointHandle

class StarHandle(AbstractHandle):
  def __init__(self, node):
      AbstractHandle.__init__(self, node)
      self.innerHandle = FourPointHandle(node, "x", "y", "inner", "inner")
      self.outerHandle = FourPointHandle(node, "x", "y", "outer", "outer")

  def draw(self, ctx):
      self.innerHandle.draw(ctx)
      self.outerHandle.draw(ctx)

  def mousePressed(self, pt):
      inner, outer = self.innerHandle, self.outerHandle

      if self.node.asFloat("inner") > self.node.asFloat("outer"):
          inner, outer = outer, inner

      inner.mousePressed(pt)
      if not inner.hasDragState():
          outer.mousePressed(pt)

  def mouseDragged(self, pt):
      inner, outer = self.innerHandle, self.outerHandle

      if self.node.asFloat("inner") > self.node.asFloat("outer"):
          inner, outer = outer, inner

      inner.mouseDragged(pt)
      if not inner.hasDragState():
          outer.mouseDragged(pt)

  def mouseReleased(self, pt):
      self.innerHandle.mouseReleased(pt)
      self.outerHandle.mouseReleased(pt)

def cook(self):
  return StarHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>star.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="points" type="int" bounding="hard" min="1.0">
      <value>20</value>
    </param>
    <param name="outer" type="float">
      <value>200.0</value>
    </param>
    <param name="inner" type="float">
      <value>100.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float" bounding="hard" min="0.0">
      <value>0.0</value>
    </param>
  </node>
  <node name="resample" prototype="builtins.root" x="230" y="110" type="nodebox.graphics.Grob">
  <description>Creates a new set of points based on the original shape.</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    # Check if a shape is connected.
    if self.shape is None: return None
    if self.method == 'length':
        return self.shape.resampleByLength(self.length)
    else:
        return self.shape.resampleByAmount(self.points, self.perContour)]]></value>
    </param>
    <param name="_image">
      <value>resample.png</value>
    </param>
    <param name="method" type="string" widget="menu">
      <value>length</value>
      <menu key="length">By Length</menu>
      <menu key="amount">By Amount</menu>
    </param>
    <param name="length" type="float" bounding="hard" min="0.01">
      <value>10.0</value>
    </param>
    <param name="points" type="int" bounding="hard" min="1.0">
      <value>10</value>
    </param>
    <param name="perContour" type="int" widget="toggle" label="Per Contour">
      <value>0</value>
    </param>
  </node>
  <node name="fit" prototype="builtins.root" x="410" y="200" type="nodebox.graphics.Grob">
  <description>Fits a shape in specified bounds</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <port name="template" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path, Transform

def cook(self):
    if self.shape is None: return None

    px, py, pw, ph = list(self.shape.bounds)

    # if a template shape is given, use its bounding rectangle,
    # otherwise use the input values.
    if self.template is not None:
        x, y, width, height = list(self.template.bounds)
        x += width / 2
        y += height / 2
    else:
        x = self.x
        y = self.y
        width = self.width
        height = self.height

    t = Transform()
    t.translate(x, y)
    t.scale(width / pw, height / ph)
    t.translate(-pw / 2 - px, -ph / 2 - py)

    return t.map(self.shape.clone())]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import FourPointHandle

def cook(self):
    if self.shape is None or self.template is not None: return None
    return FourPointHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>fit.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>300.0</value>
    </param>
    <param name="height" type="float">
      <value>300.0</value>
    </param>
  </node>
  <node name="line" prototype="builtins.root" x="320" y="30" type="nodebox.graphics.Grob">
  <description>Draws a line between two points</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path
from nodebox.util.Geometry import coordinates

def cook(self):
    p = Path()
    x1, y1 = coordinates(self.x, self.y, self.distance, self.angle)
    p.line(self.x, self.y, x1, y1)
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p.resampleByAmount(self.points, True)]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.graphics import Path
from nodebox.handle import AbstractHandle
from nodebox.util.Geometry import coordinates, angle, distance

class LineHandle(AbstractHandle):
  NONE, ORIGIN, MIDDLE, END = range(4)

  def __init__(self, node):
      AbstractHandle.__init__(self, node)
      self.dragState = LineHandle.NONE

  def draw(self, ctx):
      cx = self.node.asFloat("x")
      cy = self.node.asFloat("y")
      cornerPath = Path()
      cornerPath.fillColor = AbstractHandle.HANDLE_COLOR
      self.drawDot(cornerPath, cx, cy)
      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance"), self.node.asFloat("angle"))
      self.drawDot(cornerPath, x1, y1)
      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance") / 2, self.node.asFloat("angle"))
      self.drawDot(cornerPath, x1, y1)
      ctx.canvas.add(cornerPath)

  def mousePressed(self, pt):
      self.px = pt.x
      self.py = pt.y

      cx = self.ocx = self.node.asFloat("x")
      cy = self.ocy = self.node.asFloat("y")
      origin = self.createHitRectangle(cx, cy)

      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance"), self.node.asFloat("angle"))
      end = self.createHitRectangle(x1, y1)

      x1, y1 = coordinates(cx, cy, self.node.asFloat("distance") / 2, self.node.asFloat("angle"))
      middle = self.createHitRectangle(x1, y1)

      if origin.contains(pt):
          self.dragState = self.ORIGIN
      elif end.contains(pt):
          self.dragState = self.END
      elif middle.contains(pt):
          self.dragState = self.MIDDLE
      else:
          self.dragState = self.NONE

  def mouseDragged(self, pt):
      if self.dragState == self.NONE: return

      x = pt.x
      y = pt.y
      dx = x - self.px
      dy = y - self.py

      if (dx == 0 and dy == 0): return

      if self.dragState == self.MIDDLE:
          self.node.silentSet("x", self.ocx + dx)
          self.node.silentSet("y", self.ocy + dy)
      elif self.dragState == self.ORIGIN:
          x1, y1 = coordinates(self.node.asFloat("x"), self.node.asFloat("y"), self.node.asFloat("distance"), self.node.asFloat("angle"))
          a = angle(x, y, x1, y1)
          d = distance(x, y, x1, y1)
          self.node.silentSet("x", x)
          self.node.silentSet("y", y)
          self.node.silentSet("angle", a)
          self.node.silentSet("distance", d)
      elif self.dragState == self.END:
          a = angle(self.ocx, self.ocy, x, y)
          d = distance(self.ocx, self.ocy, x, y)
          self.node.silentSet("angle", a)
          self.node.silentSet("distance", d)

  def mouseReleased(self, pt):
      self.dragState = self.NONE


def cook(self):
  return LineHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>line.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="angle" type="float" widget="angle">
      <value>0.0</value>
    </param>
    <param name="distance" type="float">
      <value>120.0</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float" min="0.0">
      <value>1.0</value>
    </param>
    <param name="points" type="int" bounding="hard" min="2.0">
      <value>2</value>
    </param>
  </node>
  <node name="rect" prototype="builtins.root" x="140" y="30" type="nodebox.graphics.Grob">
  <description>Creates rectangles and rounded rectangles.</description>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path

def cook(self):
    p = Path()
    if self.rx == 0 and self.ry == 0:
        p.rect(self.x, self.y, self.width, self.height)
    else:
        p.roundedRect(self.x, self.y, self.width, self.height, self.rx, self.ry)
    p.fillColor = self.fill
    if self.strokeWidth > 0:
        p.strokeColor = self.stroke
        p.strokeWidth = self.strokeWidth
    else:
        p.strokeColor = None
    return p]]></value>
    </param>
    <param name="_handle">
      <value type="python"><![CDATA[from nodebox.handle import FourPointHandle
def cook(self):
    return FourPointHandle(self.node)]]></value>
    </param>
    <param name="_image">
      <value>rect.png</value>
    </param>
    <param name="x" type="float">
      <value>0.0</value>
    </param>
    <param name="y" type="float">
      <value>0.0</value>
    </param>
    <param name="width" type="float">
      <value>100.0</value>
    </param>
    <param name="height" type="float">
      <value>100.0</value>
    </param>
    <param name="rx" type="float" label="Roundness X">
      <value>0.0</value>
    </param>
    <param name="ry" type="float" label="Roundness Y">
      <value>0.0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
  <node name="wiggle" prototype="builtins.root" x="320" y="200" type="nodebox.graphics.Grob">
  <description>Relocates points based on original points with a margin.</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path
from random import seed, uniform

def cook(self):
    seed(self.seed)
    if self.shape is None: return None
    shape = self.shape.clone()
    for point in shape.points:
        dx = (uniform(0, 1) - 0.5) * self.wx * 2
        dy = (uniform(0, 1) - 0.5) * self.wy * 2
        point.x += dx
        point.y += dy
    return shape]]></value>
    </param>
    <param name="wx" type="float" label="Wiggle X">
      <value>30.0</value>
    </param>
    <param name="wy" type="float" label="Wiggle Y">
      <value>30.0</value>
    </param>
    <param name="seed" type="int" widget="seed" bounding="hard" min="0.0">
      <value>0</value>
    </param>
  </node>
  <node name="generator" prototype="builtins.root" x="50" y="30" type="nodebox.graphics.Grob">
  <description>Template for creating nodes that generator vector data.</description>
    <param name="_code">
      <value type="python"><![CDATA[# This node serves as a template for writing your own vector generators.
# Read the code in cook and replace it with your own.
from nodebox.graphics import Path

def cook(self):
    # Replace the code below.
    # Create a new path object.
    p = Path()
    # Call the rect method to draw something within the path.
    p.rect(0, 0, 100, 100)
    # Return the path object.
    return p]]></value>
    </param>
    <param name="_image">
      <value>generator.png</value>
    </param>
  </node>
  <node name="compound" prototype="builtins.root" x="50" y="290" type="nodebox.graphics.Grob">
  <description>Creates compound paths</description>
    <port name="shape" type="nodebox.graphics.Grob"/>
    <port name="shapeB" type="nodebox.graphics.Grob"/>
    <param name="_code">
      <value type="python"><![CDATA[from nodebox.graphics import Path,Color

def cook(self):
     if self.shape is None: return None
     if self.shapeB is None: return None
     p1c = self.shape.clone()
     p2c = self.shapeB.clone()
     compound = Path()
     if self.invert_difference:
         func = getattr(p1c, self.function)
         compound = func(p2c)
     else:
         func = getattr(p2c, self.function)
         compound = func(p1c)

     compound.fillColor = self.fill
     if self.strokeWidth > 0:
         compound.strokeColor = self.stroke
         compound.strokeWidth = self.strokeWidth
     else:
         compound.strokeColor = None
     # otherwise: a bit longer but maybe more comprehensible
     '''
     f = self.function
     if f == "subtracted":
         compound = p1c.subtracted(p2c)
     if f == "united":
         compound = p1c.united(p2c)
     if f == "intersected":
         compound = p1c.intersected(p2c)
     '''
     return compound]]></value>
    </param>
    <param name="_image">
      <value>compound.png</value>
    </param>
    <param name="function" type="string" widget="menu">
      <value>united</value>
      <menu key="united">union</menu>
      <menu key="subtracted">difference</menu>
      <menu key="intersected">intersect</menu>
    </param>
    <param name="invert_difference" type="int" widget="toggle">
      <value>0</value>
    </param>
    <param name="fill" type="color">
      <value>#000000ff</value>
    </param>
    <param name="stroke" type="color">
      <value>#000000ff</value>
    </param>
    <param name="strokeWidth" type="float">
      <value>0.0</value>
    </param>
  </node>
</ndbx>